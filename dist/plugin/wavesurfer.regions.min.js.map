{
  "version": 3,
  "file": "wavesurfer.regions.min.js",
  "mappings": "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",
  "sources": [
    "webpack://WaveSurfer/webpack/universalModuleDefinition",
    "webpack://WaveSurfer/webpack/bootstrap",
    "webpack://WaveSurfer/webpack/runtime/define property getters",
    "webpack://WaveSurfer/webpack/runtime/hasOwnProperty shorthand",
    "webpack://WaveSurfer/webpack/runtime/make namespace object",
    "webpack://WaveSurfer/./src/plugin/regions/region.js",
    "webpack://WaveSurfer/./src/plugin/regions/index.js"
  ],
  "sourcesContent": [
    "(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"WaveSurfer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WaveSurfer\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"regions\"] = factory();\n})(self, () => {\nreturn ",
    "// The require scope\nvar __webpack_require__ = {};\n\n",
    "// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};",
    "__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))",
    "// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};",
    "/**\r\n *  @since 4.0.0\r\n *\r\n * (Single) Region plugin class\r\n *\r\n * Must be turned into an observer before instantiating. This is done in\r\n * `RegionsPlugin` (main plugin class).\r\n *\r\n * @extends {Observer}\r\n */\r\nexport class Region {\r\n  constructor(params, regionsUtils, ws) {\r\n    this.wavesurfer = ws;\r\n    this.wrapper = ws.drawer.wrapper;\r\n    this.util = ws.util;\r\n    this.style = this.util.style;\r\n    this.regionsUtil = regionsUtils;\r\n    this.vertical = ws.drawer.params.vertical;\r\n\r\n    this.id = params.id == null ? ws.util.getId() : params.id;\r\n    this.start = Number(params.start) || 0;\r\n    this.end =\r\n      params.end == null\r\n        ? // small marker-like region\r\n          this.start +\r\n          (4 / this.wrapper.scrollWidth) * this.wavesurfer.getDuration()\r\n        : Number(params.end);\r\n    this.resize = params.resize === undefined ? true : Boolean(params.resize);\r\n    this.drag = params.drag === undefined ? true : Boolean(params.drag);\r\n    // reflect resize and drag state of region for region-updated listener\r\n    this.isResizing = false;\r\n    this.isDragging = false;\r\n    this.loop = Boolean(params.loop);\r\n    this.color = params.color || 'rgba(0, 0, 0, 0.1)';\r\n    // The left and right handleStyle properties can be set to 'none' for\r\n    // no styling or can be assigned an object containing CSS properties.\r\n    this.handleStyle = params.handleStyle || {\r\n      left: {},\r\n      right: {},\r\n    };\r\n    this.handleLeftEl = null;\r\n    this.handleRightEl = null;\r\n    this.data = params.data || {};\r\n    this.attributes = params.attributes || {};\r\n    this.showTooltip = params.showTooltip|| true;\r\n\r\n    this.maxLength = params.maxLength;\r\n    // It assumes the minLength parameter value, or the regionsMinLength parameter value, if the first one not provided\r\n    this.minLength = params.minLength;\r\n    this._onRedraw = () => this.updateRender();\r\n\r\n    this.scroll = params.scroll !== false && ws.params.scrollParent;\r\n    this.scrollSpeed = params.scrollSpeed || 1;\r\n    this.scrollThreshold = params.scrollThreshold || 10;\r\n    // Determines whether the context menu is prevented from being opened.\r\n    this.preventContextMenu =\r\n      params.preventContextMenu === undefined\r\n        ? false\r\n        : Boolean(params.preventContextMenu);\r\n\r\n    // select channel ID to set region\r\n    let channelIdx =\r\n      params.channelIdx == null ? -1 : parseInt(params.channelIdx);\r\n\r\n    let channelCount =\r\n      ws.regions.params.channelCount && ws.params.splitChannels\r\n        ? ws.regions.params.channelCount\r\n        : -1;\r\n\r\n    if (channelIdx >= ws.regions.params.channelCount) {\r\n      this.regionHeight = '0%';\r\n      return;\r\n    }\r\n    this.channelIdx = channelIdx;\r\n    this.regionHeight = '100%';\r\n    this.marginTop = '0px';\r\n\r\n    if (channelIdx !== -1) {\r\n      if (channelCount >= 0) {\r\n        this.regionHeight = Math.floor((1 / channelCount) * 100) + '%';\r\n        this.marginTop = this.wavesurfer.getHeight() * channelIdx + 'px';\r\n      }\r\n    }\r\n\r\n    this.formatTimeCallback = params.formatTimeCallback;\r\n    this.edgeScrollWidth = params.edgeScrollWidth;\r\n    this.bindInOut();\r\n    this.render();\r\n    this.wavesurfer.on('zoom', this._onRedraw);\r\n    this.wavesurfer.on('redraw', this._onRedraw);\r\n    this.wavesurfer.fireEvent('region-created', this);\r\n  }\r\n\r\n  /* Update region params. */\r\n  update(params, eventParams) {\r\n    if (params.start != null) {\r\n      this.start = Number(params.start);\r\n    }\r\n    if (params.end != null) {\r\n      this.end = Number(params.end);\r\n    }\r\n    if (params.loop != null) {\r\n      this.loop = Boolean(params.loop);\r\n    }\r\n    if (params.color != null) {\r\n      this.color = params.color;\r\n    }\r\n    if (params.handleStyle != null) {\r\n      this.handleStyle = params.handleStyle;\r\n    }\r\n    if (params.data != null) {\r\n      this.data = params.data;\r\n    }\r\n    if (params.resize != null) {\r\n      this.resize = Boolean(params.resize);\r\n      this.updateHandlesResize(this.resize);\r\n    }\r\n    if (params.drag != null) {\r\n      this.drag = Boolean(params.drag);\r\n    }\r\n    if (params.maxLength != null) {\r\n      this.maxLength = Number(params.maxLength);\r\n    }\r\n    if (params.minLength != null) {\r\n      this.minLength = Number(params.minLength);\r\n    }\r\n    if (params.attributes != null) {\r\n      this.attributes = params.attributes;\r\n    }\r\n\r\n    this.updateRender();\r\n    this.fireEvent('update');\r\n    this.wavesurfer.fireEvent('region-updated', this, eventParams);\r\n  }\r\n\r\n  /* Remove a single region. */\r\n  remove() {\r\n    if (this.element) {\r\n      this.wrapper.removeChild(this.element.domElement);\r\n      this.element = null;\r\n      this.fireEvent('remove');\r\n      this.wavesurfer.un('zoom', this._onRedraw);\r\n      this.wavesurfer.un('redraw', this._onRedraw);\r\n      this.wavesurfer.fireEvent('region-removed', this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Play the audio region.\r\n   * @param {number} start Optional offset to start playing at\r\n   */\r\n  play(start) {\r\n    const s = start || this.start;\r\n    this.wavesurfer.play(s, this.end);\r\n    this.fireEvent('play');\r\n    this.wavesurfer.fireEvent('region-play', this);\r\n  }\r\n\r\n  /**\r\n   * Play the audio region in a loop.\r\n   * @param {number} start Optional offset to start playing at\r\n   * */\r\n  playLoop(start) {\r\n    this.loop = true;\r\n    this.play(start);\r\n  }\r\n\r\n  /**\r\n   * Set looping on/off.\r\n   * @param {boolean} loop True if should play in loop\r\n   */\r\n  setLoop(loop) {\r\n    this.loop = loop;\r\n  }\r\n\r\n  /* Render a region as a DOM element. */\r\n  render() {\r\n    this.element = this.util.withOrientation(\r\n      this.wrapper.appendChild(document.createElement('region')),\r\n      this.vertical\r\n    );\r\n\r\n    this.element.className = 'wavesurfer-region';\r\n    if (this.showTooltip) {\r\n      this.element.title = this.formatTime(this.start, this.end);\r\n    }\r\n    this.element.setAttribute('data-id', this.id);\r\n\r\n    for (const attrname in this.attributes) {\r\n      this.element.setAttribute(\r\n        'data-region-' + attrname,\r\n        this.attributes[attrname]\r\n      );\r\n    }\r\n\r\n    this.style(this.element, {\r\n      position: 'absolute',\r\n      height: this.regionHeight,\r\n      top: this.marginTop,\r\n    });\r\n\r\n    /* Resize handles */\r\n    if (this.resize) {\r\n      this.handleLeftEl = this.util.withOrientation(\r\n        this.element.appendChild(document.createElement('handle')),\r\n        this.vertical\r\n      );\r\n      this.handleRightEl = this.util.withOrientation(\r\n        this.element.appendChild(document.createElement('handle')),\r\n        this.vertical\r\n      );\r\n\r\n      this.handleLeftEl.className = 'wavesurfer-handle wavesurfer-handle-start';\r\n      this.handleRightEl.className = 'wavesurfer-handle wavesurfer-handle-end';\r\n\r\n      // Default CSS properties for both handles.\r\n      const css = {\r\n        cursor: this.vertical ? 'row-resize' : 'col-resize',\r\n        position: 'absolute',\r\n        top: '0px',\r\n        width: '2px',\r\n        height: '100%',\r\n        backgroundColor: 'rgba(0, 0, 0, 1)',\r\n      };\r\n\r\n      // Merge CSS properties per handle.\r\n      const handleLeftCss =\r\n        this.handleStyle.left !== 'none'\r\n          ? Object.assign({ left: '0px' }, css, this.handleStyle.left)\r\n          : null;\r\n      const handleRightCss =\r\n        this.handleStyle.right !== 'none'\r\n          ? Object.assign({ right: '0px' }, css, this.handleStyle.right)\r\n          : null;\r\n\r\n      if (handleLeftCss) {\r\n        this.style(this.handleLeftEl, handleLeftCss);\r\n      }\r\n\r\n      if (handleRightCss) {\r\n        this.style(this.handleRightEl, handleRightCss);\r\n      }\r\n    }\r\n\r\n    this.updateRender();\r\n    this.bindEvents();\r\n  }\r\n\r\n  formatTime(start, end) {\r\n    if (this.formatTimeCallback) {\r\n      return this.formatTimeCallback(start, end);\r\n    }\r\n    return (start == end ? [start] : [start, end])\r\n      .map((time) =>\r\n        [\r\n          Math.floor((time % 3600) / 60), // minutes\r\n          ('00' + Math.floor(time % 60)).slice(-2), // seconds\r\n        ].join(':')\r\n      )\r\n      .join('-');\r\n  }\r\n\r\n  getWidth() {\r\n    return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;\r\n  }\r\n\r\n  /* Update element's position, width, color. */\r\n  updateRender() {\r\n    // duration varies during loading process, so don't overwrite important data\r\n    const dur = this.wavesurfer.getDuration();\r\n    const width = this.getWidth();\r\n\r\n    let startLimited = this.start;\r\n    let endLimited = this.end;\r\n    if (startLimited < 0) {\r\n      startLimited = 0;\r\n      endLimited = endLimited - startLimited;\r\n    }\r\n    if (endLimited > dur) {\r\n      endLimited = dur;\r\n      startLimited = dur - (endLimited - startLimited);\r\n    }\r\n\r\n    if (this.minLength != null) {\r\n      endLimited = Math.max(startLimited + this.minLength, endLimited);\r\n    }\r\n\r\n    if (this.maxLength != null) {\r\n      endLimited = Math.min(startLimited + this.maxLength, endLimited);\r\n    }\r\n\r\n    if (this.element != null) {\r\n      // Calculate the left and width values of the region such that\r\n      // no gaps appear between regions.\r\n      const left = Math.round((startLimited / dur) * width);\r\n      const regionWidth = Math.round((endLimited / dur) * width) - left;\r\n\r\n      this.style(this.element, {\r\n        left: left + 'px',\r\n        width: regionWidth + 'px',\r\n        backgroundColor: this.color,\r\n        cursor: this.drag ? 'move' : 'default',\r\n      });\r\n\r\n      for (const attrname in this.attributes) {\r\n        this.element.setAttribute(\r\n          'data-region-' + attrname,\r\n          this.attributes[attrname]\r\n        );\r\n      }\r\n\r\n      if (this.showTooltip) {\r\n        this.element.title = this.formatTime(this.start, this.end);\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Bind audio events. */\r\n  bindInOut() {\r\n    this.firedIn = false;\r\n    this.firedOut = false;\r\n\r\n    const onProcess = (time) => {\r\n      let start = Math.round(this.start * 10) / 10;\r\n      let end = Math.round(this.end * 10) / 10;\r\n      time = Math.round(time * 10) / 10;\r\n\r\n      if (!this.firedOut && this.firedIn && (start > time || end <= time)) {\r\n        this.firedOut = true;\r\n        this.firedIn = false;\r\n        this.fireEvent('out');\r\n        this.wavesurfer.fireEvent('region-out', this);\r\n      }\r\n      if (!this.firedIn && start <= time && end > time) {\r\n        this.firedIn = true;\r\n        this.firedOut = false;\r\n        this.fireEvent('in');\r\n        this.wavesurfer.fireEvent('region-in', this);\r\n      }\r\n    };\r\n\r\n    this.wavesurfer.backend.on('audioprocess', onProcess);\r\n\r\n    this.on('remove', () => {\r\n      this.wavesurfer.backend.un('audioprocess', onProcess);\r\n    });\r\n\r\n    /* Loop playback. */\r\n    this.on('out', () => {\r\n      if (this.loop) {\r\n        const realTime = this.wavesurfer.getCurrentTime();\r\n        if (realTime >= this.start && realTime <= this.end) {\r\n          this.wavesurfer.play(this.start);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /* Bind DOM events. */\r\n  bindEvents() {\r\n    const preventContextMenu = this.preventContextMenu;\r\n\r\n    this.element.addEventListener('mouseenter', (e) => {\r\n      this.fireEvent('mouseenter', e);\r\n      this.wavesurfer.fireEvent('region-mouseenter', this, e);\r\n    });\r\n\r\n    this.element.addEventListener('mouseleave', (e) => {\r\n      this.fireEvent('mouseleave', e);\r\n      this.wavesurfer.fireEvent('region-mouseleave', this, e);\r\n    });\r\n\r\n    this.element.addEventListener('click', (e) => {\r\n      e.preventDefault();\r\n      this.fireEvent('click', e);\r\n      this.wavesurfer.fireEvent('region-click', this, e);\r\n    });\r\n\r\n    this.element.addEventListener('dblclick', (e) => {\r\n      e.stopPropagation();\r\n      e.preventDefault();\r\n      this.fireEvent('dblclick', e);\r\n      this.wavesurfer.fireEvent('region-dblclick', this, e);\r\n    });\r\n\r\n    this.element.addEventListener('contextmenu', (e) => {\r\n      if (preventContextMenu) {\r\n        e.preventDefault();\r\n      }\r\n      this.fireEvent('contextmenu', e);\r\n      this.wavesurfer.fireEvent('region-contextmenu', this, e);\r\n    });\r\n\r\n    /* Drag or resize on mousemove. */\r\n    if (this.drag || this.resize) {\r\n      this.bindDragEvents();\r\n    }\r\n  }\r\n\r\n  bindDragEvents() {\r\n    const container = this.wavesurfer.drawer.container;\r\n    const scrollSpeed = this.scrollSpeed;\r\n    const scrollThreshold = this.scrollThreshold;\r\n    let startTime;\r\n    let touchId;\r\n    let drag;\r\n    let maxScroll;\r\n    let resize;\r\n    let updated = false;\r\n    let scrollDirection;\r\n    let wrapperRect;\r\n    let regionLeftHalfTime;\r\n    let regionRightHalfTime;\r\n\r\n    // Scroll when the user is dragging within the threshold\r\n    const edgeScroll = (event) => {\r\n      let orientedEvent = this.util.withOrientation(event, this.vertical);\r\n      const duration = this.wavesurfer.getDuration();\r\n      if (!scrollDirection || (!drag && !resize)) {\r\n        return;\r\n      }\r\n\r\n      const x = orientedEvent.clientX;\r\n      let distanceBetweenCursorAndWrapperEdge = 0;\r\n      let regionHalfTimeWidth = 0;\r\n      let adjustment = 0;\r\n\r\n      // Get the currently selected time according to the mouse position\r\n      let time = this.regionsUtil.getRegionSnapToGridValue(\r\n        this.wavesurfer.drawer.handleEvent(event) * duration\r\n      );\r\n\r\n      if (drag) {\r\n        // Considering the point of contact with the region while edgescrolling\r\n        if (scrollDirection === -1) {\r\n          regionHalfTimeWidth =\r\n            regionLeftHalfTime * this.wavesurfer.params.minPxPerSec;\r\n          distanceBetweenCursorAndWrapperEdge = x - wrapperRect.left;\r\n        } else {\r\n          regionHalfTimeWidth =\r\n            regionRightHalfTime * this.wavesurfer.params.minPxPerSec;\r\n          distanceBetweenCursorAndWrapperEdge = wrapperRect.right - x;\r\n        }\r\n      } else {\r\n        // Considering minLength while edgescroll\r\n        let minLength = this.minLength;\r\n        if (!minLength) {\r\n          minLength = 0;\r\n        }\r\n\r\n        if (resize === 'start') {\r\n          if (time > this.end - minLength) {\r\n            time = this.end - minLength;\r\n            adjustment = scrollSpeed * scrollDirection;\r\n          }\r\n\r\n          if (time < 0) {\r\n            time = 0;\r\n          }\r\n        } else if (resize === 'end') {\r\n          if (time < this.start + minLength) {\r\n            time = this.start + minLength;\r\n            adjustment = scrollSpeed * scrollDirection;\r\n          }\r\n\r\n          if (time > duration) {\r\n            time = duration;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Don't edgescroll if region has reached min or max limit\r\n      const wrapperScrollLeft = this.wrapper.scrollLeft;\r\n\r\n      if (scrollDirection === -1) {\r\n        if (Math.round(wrapperScrollLeft) === 0) {\r\n          return;\r\n        }\r\n\r\n        if (\r\n          Math.round(\r\n            wrapperScrollLeft -\r\n              regionHalfTimeWidth +\r\n              distanceBetweenCursorAndWrapperEdge\r\n          ) <= 0\r\n        ) {\r\n          return;\r\n        }\r\n      } else {\r\n        if (Math.round(wrapperScrollLeft) === maxScroll) {\r\n          return;\r\n        }\r\n\r\n        if (\r\n          Math.round(\r\n            wrapperScrollLeft +\r\n              regionHalfTimeWidth -\r\n              distanceBetweenCursorAndWrapperEdge\r\n          ) >= maxScroll\r\n        ) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      // Update scroll position\r\n      let scrollLeft =\r\n        wrapperScrollLeft - adjustment + scrollSpeed * scrollDirection;\r\n\r\n      if (scrollDirection === -1) {\r\n        const calculatedLeft = Math.max(\r\n          0 + regionHalfTimeWidth - distanceBetweenCursorAndWrapperEdge,\r\n          scrollLeft\r\n        );\r\n        this.wrapper.scrollLeft = scrollLeft = calculatedLeft;\r\n      } else {\r\n        const calculatedRight = Math.min(\r\n          maxScroll - regionHalfTimeWidth + distanceBetweenCursorAndWrapperEdge,\r\n          scrollLeft\r\n        );\r\n        this.wrapper.scrollLeft = scrollLeft = calculatedRight;\r\n      }\r\n\r\n      const delta = time - startTime;\r\n      startTime = time;\r\n\r\n      // Continue dragging or resizing\r\n      drag ? this.onDrag(delta) : this.onResize(delta, resize);\r\n\r\n      // Repeat\r\n      window.requestAnimationFrame(() => {\r\n        edgeScroll(event);\r\n      });\r\n    };\r\n\r\n    const onDown = (event) => {\r\n      const duration = this.wavesurfer.getDuration();\r\n      if (event.touches && event.touches.length > 1) {\r\n        return;\r\n      }\r\n      touchId = event.targetTouches ? event.targetTouches[0].identifier : null;\r\n\r\n      // stop the event propagation, if this region is resizable or draggable\r\n      // and the event is therefore handled here.\r\n      if (this.drag || this.resize) {\r\n        event.stopPropagation();\r\n      }\r\n\r\n      // Store the selected startTime we begun dragging or resizing\r\n      startTime = this.regionsUtil.getRegionSnapToGridValue(\r\n        this.wavesurfer.drawer.handleEvent(event, true) * duration\r\n      );\r\n\r\n      // Store the selected point of contact when we begin dragging\r\n      regionLeftHalfTime = startTime - this.start;\r\n      regionRightHalfTime = this.end - startTime;\r\n\r\n      // Store for scroll calculations\r\n      maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;\r\n\r\n      wrapperRect = this.util.withOrientation(\r\n        this.wrapper.getBoundingClientRect(),\r\n        this.vertical\r\n      );\r\n\r\n      this.isResizing = false;\r\n      this.isDragging = false;\r\n      if (event.target.tagName.toLowerCase() === 'handle') {\r\n        this.isResizing = true;\r\n        resize = event.target.classList.contains('wavesurfer-handle-start')\r\n          ? 'start'\r\n          : 'end';\r\n      } else {\r\n        this.isDragging = true;\r\n        drag = true;\r\n        resize = false;\r\n      }\r\n    };\r\n    const onUp = (event) => {\r\n      if (event.touches && event.touches.length > 1) {\r\n        return;\r\n      }\r\n\r\n      if (drag || resize) {\r\n        this.isDragging = false;\r\n        this.isResizing = false;\r\n        drag = false;\r\n        scrollDirection = null;\r\n        resize = false;\r\n      }\r\n\r\n      if (updated) {\r\n        updated = false;\r\n        this.util.preventClick();\r\n        this.fireEvent('update-end', event);\r\n        this.wavesurfer.fireEvent('region-update-end', this, event);\r\n      }\r\n    };\r\n    const onMove = (event) => {\r\n      const duration = this.wavesurfer.getDuration();\r\n      let orientedEvent = this.util.withOrientation(event, this.vertical);\r\n\r\n      if (event.touches && event.touches.length > 1) {\r\n        return;\r\n      }\r\n      if (event.targetTouches && event.targetTouches[0].identifier != touchId) {\r\n        return;\r\n      }\r\n      if (!drag && !resize) {\r\n        return;\r\n      }\r\n\r\n      const oldTime = startTime;\r\n      let time = this.regionsUtil.getRegionSnapToGridValue(\r\n        this.wavesurfer.drawer.handleEvent(event) * duration\r\n      );\r\n\r\n      if (drag) {\r\n        // To maintain relative cursor start point while dragging\r\n        const maxEnd = this.wavesurfer.getDuration();\r\n        if (time > maxEnd - regionRightHalfTime) {\r\n          time = maxEnd - regionRightHalfTime;\r\n        }\r\n\r\n        if (time - regionLeftHalfTime < 0) {\r\n          time = regionLeftHalfTime;\r\n        }\r\n      }\r\n\r\n      if (resize) {\r\n        // To maintain relative cursor start point while resizing\r\n        // we have to handle for minLength\r\n        let minLength = this.minLength;\r\n        if (!minLength) {\r\n          minLength = 0;\r\n        }\r\n\r\n        if (resize === 'start') {\r\n          if (time > this.end - minLength) {\r\n            time = this.end - minLength;\r\n          }\r\n\r\n          if (time < 0) {\r\n            time = 0;\r\n          }\r\n        } else if (resize === 'end') {\r\n          if (time < this.start + minLength) {\r\n            time = this.start + minLength;\r\n          }\r\n\r\n          if (time > duration) {\r\n            time = duration;\r\n          }\r\n        }\r\n      }\r\n\r\n      let delta = time - startTime;\r\n      startTime = time;\r\n\r\n      // Drag\r\n      if (this.drag && drag) {\r\n        updated = updated || !!delta;\r\n        this.onDrag(delta);\r\n      }\r\n\r\n      // Resize\r\n      if (this.resize && resize) {\r\n        updated = updated || !!delta;\r\n        this.onResize(delta, resize);\r\n      }\r\n\r\n      if (this.scroll && container.clientWidth < this.wrapper.scrollWidth) {\r\n        // Triggering edgescroll from within edgeScrollWidth\r\n        let x = orientedEvent.clientX;\r\n\r\n        // Check direction\r\n        if (x < wrapperRect.left + this.edgeScrollWidth) {\r\n          scrollDirection = -1;\r\n        } else if (x > wrapperRect.right - this.edgeScrollWidth) {\r\n          scrollDirection = 1;\r\n        } else {\r\n          scrollDirection = null;\r\n        }\r\n\r\n        if (scrollDirection) {\r\n          edgeScroll(event);\r\n        }\r\n      }\r\n    };\r\n\r\n    this.element.addEventListener('mousedown', onDown);\r\n    this.element.addEventListener('touchstart', onDown);\r\n\r\n    document.body.addEventListener('mousemove', onMove);\r\n    document.body.addEventListener('touchmove', onMove, { passive: false });\r\n\r\n    document.addEventListener('mouseup', onUp);\r\n    document.body.addEventListener('touchend', onUp);\r\n\r\n    this.on('remove', () => {\r\n      document.removeEventListener('mouseup', onUp);\r\n      document.body.removeEventListener('touchend', onUp);\r\n      document.body.removeEventListener('mousemove', onMove);\r\n      document.body.removeEventListener('touchmove', onMove);\r\n    });\r\n\r\n    this.wavesurfer.on('destroy', () => {\r\n      document.removeEventListener('mouseup', onUp);\r\n      document.body.removeEventListener('touchend', onUp);\r\n    });\r\n  }\r\n\r\n  onDrag(delta) {\r\n    const maxEnd = this.wavesurfer.getDuration();\r\n    if (this.end + delta > maxEnd) {\r\n      delta = maxEnd - this.end;\r\n    }\r\n\r\n    if (this.start + delta < 0) {\r\n      delta = this.start * -1;\r\n    }\r\n\r\n    const eventParams = {\r\n      direction: this._getDragDirection(delta),\r\n      action: 'drag',\r\n    };\r\n\r\n    this.update(\r\n      {\r\n        start: this.start + delta,\r\n        end: this.end + delta,\r\n      },\r\n      eventParams\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the direction of dragging region based on delta\r\n   * Negative delta means region is moving to the left\r\n   * Positive - to the right\r\n   * For zero delta the direction is not defined\r\n   * @param {number} delta Drag offset\r\n   * @returns {string|null} Direction 'left', 'right' or null\r\n   */\r\n  _getDragDirection(delta) {\r\n    if (delta < 0) {\r\n      return 'left';\r\n    }\r\n    if (delta > 0) {\r\n      return 'right';\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * @example\r\n   * onResize(-5, 'start') // Moves the start point 5 seconds back\r\n   * onResize(0.5, 'end') // Moves the end point 0.5 seconds forward\r\n   *\r\n   * @param {number} delta How much to add or subtract, given in seconds\r\n   * @param {string} direction 'start 'or 'end'\r\n   */\r\n  onResize(delta, direction) {\r\n    const duration = this.wavesurfer.getDuration();\r\n    const eventParams = {\r\n      action: 'resize',\r\n      direction: direction === 'start' ? 'left' : 'right',\r\n    };\r\n\r\n    if (direction === 'start') {\r\n      // Check if changing the start by the given delta would result in the region being smaller than minLength\r\n      if (delta > 0 && this.end - (this.start + delta) < this.minLength) {\r\n        delta = this.end - this.minLength - this.start;\r\n      }\r\n\r\n      // Check if changing the start by the given delta would result in the region being larger than maxLength\r\n      if (delta < 0 && this.end - (this.start + delta) > this.maxLength) {\r\n        delta = this.end - this.start - this.maxLength;\r\n      }\r\n\r\n      if (delta < 0 && this.start + delta < 0) {\r\n        delta = this.start * -1;\r\n      }\r\n\r\n      this.update(\r\n        {\r\n          start: Math.min(this.start + delta, this.end),\r\n          end: Math.max(this.start + delta, this.end),\r\n        },\r\n        eventParams\r\n      );\r\n    } else {\r\n      // Check if changing the end by the given delta would result in the region being smaller than minLength\r\n      if (delta < 0 && this.end + delta - this.start < this.minLength) {\r\n        delta = this.start + this.minLength - this.end;\r\n      }\r\n\r\n      // Check if changing the end by the given delta would result in the region being larger than maxLength\r\n      if (delta > 0 && this.end + delta - this.start > this.maxLength) {\r\n        delta = this.maxLength - (this.end - this.start);\r\n      }\r\n\r\n      if (delta > 0 && this.end + delta > duration) {\r\n        delta = duration - this.end;\r\n      }\r\n\r\n      this.update(\r\n        {\r\n          start: Math.min(this.end + delta, this.start),\r\n          end: Math.max(this.end + delta, this.start),\r\n        },\r\n        eventParams\r\n      );\r\n    }\r\n  }\r\n\r\n  updateHandlesResize(resize) {\r\n    let cursorStyle;\r\n    if (resize) {\r\n      cursorStyle = this.vertical ? 'row-resize' : 'col-resize';\r\n    } else {\r\n      cursorStyle = 'auto';\r\n    }\r\n\r\n    this.handleLeftEl && this.style(this.handleLeftEl, { cursor: cursorStyle });\r\n    this.handleRightEl &&\r\n      this.style(this.handleRightEl, { cursor: cursorStyle });\r\n  }\r\n}\r\n",
    "/**\r\n *  @since 4.0.0 This class has been split\r\n *\r\n * @typedef {Object} RegionsPluginParams\r\n * @property {?boolean} dragSelection Enable creating regions by dragging with\r\n * the mouse\r\n * @property {?RegionParams[]} regions Regions that should be added upon\r\n * initialisation\r\n * @property {number} slop=2 The sensitivity of the mouse dragging\r\n * @property {?number} snapToGridInterval Snap the regions to a grid of the specified multiples in seconds\r\n * @property {?number} snapToGridOffset Shift the snap-to-grid by the specified seconds. May also be negative.\r\n * @property {?boolean} deferInit Set to true to manually call\r\n * @property {number} maxRegions Maximum number of regions that may be created by the user at one time.\r\n * `initPlugin('regions')`\r\n * @property {function} formatTimeCallback Allows custom formating for region tooltip.\r\n * @property {?number} edgeScrollWidth='5% from container edges' Optional width for edgeScroll to start\r\n */\r\n\r\n/**\r\n * @typedef {Object} RegionParams\r\n * @desc The parameters used to describe a region.\r\n * @example wavesurfer.addRegion(regionParams);\r\n * @property {string} id=â†’random The id of the region\r\n * @property {number} start=0 The start position of the region (in seconds).\r\n * @property {number} end=0 The end position of the region (in seconds).\r\n * @property {?boolean} loop Whether to loop the region when played back.\r\n * @property {boolean} drag=true Allow/disallow dragging the region.\r\n * @property {boolean} resize=true Allow/disallow resizing the region.\r\n * @property {string} [color='rgba(0, 0, 0, 0.1)'] HTML color code.\r\n * @property {?number} channelIdx Select channel to draw the region on (if there are multiple channel waveforms).\r\n * @property {?object} handleStyle A set of CSS properties used to style the left and right handle.\r\n * @property {?boolean} preventContextMenu=false Determines whether the context menu is prevented from being opened.\r\n * @property {boolean} showTooltip=true Enable/disable tooltip displaying start and end times when hovering over region.\r\n */\r\n\r\nimport {Region} from \"./region.js\";\r\n\r\n/**\r\n * Regions are visual overlays on waveform that can be used to play and loop\r\n * portions of audio. Regions can be dragged and resized.\r\n *\r\n * Visual customization is possible via CSS (using the selectors\r\n * `.wavesurfer-region` and `.wavesurfer-handle`).\r\n *\r\n * @implements {PluginClass}\r\n * @extends {Observer}\r\n *\r\n * @example\r\n * // es6\r\n * import RegionsPlugin from 'wavesurfer.regions.js';\r\n *\r\n * // commonjs\r\n * var RegionsPlugin = require('wavesurfer.regions.js');\r\n *\r\n * // if you are using <script> tags\r\n * var RegionsPlugin = window.WaveSurfer.regions;\r\n *\r\n * // ... initialising wavesurfer with the plugin\r\n * var wavesurfer = WaveSurfer.create({\r\n *   // wavesurfer options ...\r\n *   plugins: [\r\n *     RegionsPlugin.create({\r\n *       // plugin options ...\r\n *     })\r\n *   ]\r\n * });\r\n */\r\nexport default class RegionsPlugin {\r\n    /**\r\n     * Regions plugin definition factory\r\n     *\r\n     * This function must be used to create a plugin definition which can be\r\n     * used by wavesurfer to correctly instantiate the plugin.\r\n     *\r\n     * @param {RegionsPluginParams} params parameters use to initialise the plugin\r\n     * @return {PluginDefinition} an object representing the plugin\r\n     */\r\n    static create(params) {\r\n        return {\r\n            name: 'regions',\r\n            deferInit: params && params.deferInit ? params.deferInit : false,\r\n            params: params,\r\n            staticProps: {\r\n                addRegion(options) {\r\n                    if (!this.initialisedPluginList.regions) {\r\n                        this.initPlugin('regions');\r\n                    }\r\n                    return this.regions.add(options);\r\n                },\r\n\r\n                clearRegions() {\r\n                    this.regions && this.regions.clear();\r\n                },\r\n\r\n                enableDragSelection(options) {\r\n                    if (!this.initialisedPluginList.regions) {\r\n                        this.initPlugin('regions');\r\n                    }\r\n                    this.regions.enableDragSelection(options);\r\n                },\r\n\r\n                disableDragSelection() {\r\n                    this.regions.disableDragSelection();\r\n                }\r\n            },\r\n            instance: RegionsPlugin\r\n        };\r\n    }\r\n\r\n    constructor(params, ws) {\r\n        this.params = params;\r\n        this.wavesurfer = ws;\r\n        this.util = {\r\n            ...ws.util,\r\n            getRegionSnapToGridValue: value => {\r\n                return this.getRegionSnapToGridValue(value, params);\r\n            }\r\n        };\r\n        this.maxRegions = params.maxRegions;\r\n        this.regionsMinLength = params.regionsMinLength || null;\r\n\r\n        // turn the plugin instance into an observer\r\n        const observerPrototypeKeys = Object.getOwnPropertyNames(\r\n            this.util.Observer.prototype\r\n        );\r\n        observerPrototypeKeys.forEach(key => {\r\n            Region.prototype[key] = this.util.Observer.prototype[key];\r\n        });\r\n        this.wavesurfer.Region = Region;\r\n\r\n        // By default, scroll the container if the user drags a region\r\n        // within 5% (based on its initial size) of its edge\r\n        const scrollWidthProportion = 0.05;\r\n        this._onBackendCreated = () => {\r\n            this.wrapper = this.wavesurfer.drawer.wrapper;\r\n            this.orientation = this.wavesurfer.drawer.orientation;\r\n            this.defaultEdgeScrollWidth = this.wrapper.clientWidth * scrollWidthProportion;\r\n            if (this.params.regions) {\r\n                this.params.regions.forEach(region => {\r\n                    this.add(region);\r\n                });\r\n            }\r\n        };\r\n\r\n        // Id-based hash of regions\r\n        this.list = {};\r\n        this._onReady = () => {\r\n            this.wrapper = this.wavesurfer.drawer.wrapper;\r\n            this.vertical = this.wavesurfer.drawer.params.vertical;\r\n            if (this.params.dragSelection) {\r\n                this.enableDragSelection(this.params);\r\n            }\r\n            Object.keys(this.list).forEach(id => {\r\n                this.list[id].updateRender();\r\n            });\r\n        };\r\n    }\r\n\r\n    init() {\r\n        // Check if ws is ready\r\n        if (this.wavesurfer.isReady) {\r\n            this._onBackendCreated();\r\n            this._onReady();\r\n        } else {\r\n            this.wavesurfer.once('ready', this._onReady);\r\n            this.wavesurfer.once('backend-created', this._onBackendCreated);\r\n        }\r\n    }\r\n\r\n    destroy() {\r\n        this.wavesurfer.un('ready', this._onReady);\r\n        this.wavesurfer.un('backend-created', this._onBackendCreated);\r\n        // Disabling `region-removed' because destroying the plugin calls\r\n        // the Region.remove() method that is also used to remove regions based\r\n        // on user input. This can cause confusion since teardown is not a\r\n        // user event, but would emit `region-removed` as if it was.\r\n        this.wavesurfer.setDisabledEventEmissions(['region-removed']);\r\n        this.disableDragSelection();\r\n        this.clear();\r\n    }\r\n\r\n    /**\r\n     * check to see if adding a new region would exceed maxRegions\r\n     * @return {boolean} whether we should proceed and create a region\r\n     * @private\r\n     */\r\n    wouldExceedMaxRegions() {\r\n        return (\r\n            this.maxRegions && Object.keys(this.list).length >= this.maxRegions\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Add a region\r\n     *\r\n     * @param {object} params Region parameters\r\n     * @return {Region} The created region\r\n     */\r\n    add(params) {\r\n        if (this.wouldExceedMaxRegions()) {\r\n            return null;\r\n        }\r\n\r\n        params = {\r\n            edgeScrollWidth: this.params.edgeScrollWidth || this.defaultEdgeScrollWidth,\r\n            ...params\r\n        };\r\n\r\n        // Take formatTimeCallback from plugin params if not already set\r\n        if (!params.formatTimeCallback && this.params.formatTimeCallback) {\r\n            params = {...params, formatTimeCallback: this.params.formatTimeCallback};\r\n        }\r\n\r\n        if (!params.minLength && this.regionsMinLength) {\r\n            params = {...params, minLength: this.regionsMinLength};\r\n        }\r\n\r\n        const region = new this.wavesurfer.Region(params, this.util, this.wavesurfer);\r\n\r\n        this.list[region.id] = region;\r\n\r\n        region.on('remove', () => {\r\n            delete this.list[region.id];\r\n        });\r\n\r\n        return region;\r\n    }\r\n\r\n    /**\r\n     * Remove all regions\r\n     */\r\n    clear() {\r\n        Object.keys(this.list).forEach(id => {\r\n            this.list[id].remove();\r\n        });\r\n    }\r\n\r\n    enableDragSelection(params) {\r\n        this.disableDragSelection();\r\n\r\n        const slop = params.slop || 2;\r\n        const container = this.wavesurfer.drawer.container;\r\n        const scroll =\r\n            params.scroll !== false && this.wavesurfer.params.scrollParent;\r\n        const scrollSpeed = params.scrollSpeed || 1;\r\n        const scrollThreshold = params.scrollThreshold || 10;\r\n        let drag;\r\n        let duration = this.wavesurfer.getDuration();\r\n        let maxScroll;\r\n        let start;\r\n        let region;\r\n        let touchId;\r\n        let pxMove = 0;\r\n        let scrollDirection;\r\n        let wrapperRect;\r\n\r\n        // Scroll when the user is dragging within the threshold\r\n        const edgeScroll = e => {\r\n            if (!region || !scrollDirection) {\r\n                return;\r\n            }\r\n\r\n            // Update scroll position\r\n            let scrollLeft =\r\n                this.wrapper.scrollLeft + scrollSpeed * scrollDirection;\r\n            this.wrapper.scrollLeft = scrollLeft = Math.min(\r\n                maxScroll,\r\n                Math.max(0, scrollLeft)\r\n            );\r\n\r\n            // Update range\r\n            const end = this.wavesurfer.drawer.handleEvent(e);\r\n            region.update({\r\n                start: Math.min(end * duration, start * duration),\r\n                end: Math.max(end * duration, start * duration)\r\n            });\r\n\r\n            // Check that there is more to scroll and repeat\r\n            if (scrollLeft < maxScroll && scrollLeft > 0) {\r\n                window.requestAnimationFrame(() => {\r\n                    edgeScroll(e);\r\n                });\r\n            }\r\n        };\r\n\r\n        const eventDown = e => {\r\n            if (e.touches && e.touches.length > 1) {\r\n                return;\r\n            }\r\n            duration = this.wavesurfer.getDuration();\r\n            touchId = e.targetTouches ? e.targetTouches[0].identifier : null;\r\n\r\n            // Store for scroll calculations\r\n            maxScroll = this.wrapper.scrollWidth -\r\n                this.wrapper.clientWidth;\r\n            wrapperRect = this.util.withOrientation(\r\n                this.wrapper.getBoundingClientRect(),\r\n                this.vertical\r\n            );\r\n\r\n            // set the region channel index based on the clicked area\r\n            if (this.wavesurfer.params.splitChannels) {\r\n                const y = (e.touches ? e.touches[0].clientY : e.clientY) - wrapperRect.top;\r\n                const channelCount = this.wavesurfer.backend.buffer != null ? this.wavesurfer.backend.buffer.numberOfChannels : 1;\r\n                const channelHeight = this.wrapper.clientHeight / channelCount;\r\n                const channelIdx = Math.floor(y / channelHeight);\r\n                params.channelIdx = channelIdx;\r\n                const channelColors = this.wavesurfer.params.splitChannelsOptions.channelColors[channelIdx];\r\n                if (channelColors && channelColors.dragColor) {\r\n                    params.color = channelColors.dragColor;\r\n                }\r\n            }\r\n\r\n            drag = true;\r\n            start = this.wavesurfer.drawer.handleEvent(e, true);\r\n            region = null;\r\n            scrollDirection = null;\r\n        };\r\n        this.wrapper.addEventListener('mousedown', eventDown);\r\n        this.wrapper.addEventListener('touchstart', eventDown);\r\n        this.on('disable-drag-selection', () => {\r\n            this.wrapper.removeEventListener('touchstart', eventDown);\r\n            this.wrapper.removeEventListener('mousedown', eventDown);\r\n        });\r\n\r\n        const eventUp = e => {\r\n            if (e.touches && e.touches.length > 1) {\r\n                return;\r\n            }\r\n\r\n            drag = false;\r\n            pxMove = 0;\r\n            scrollDirection = null;\r\n\r\n            if (region) {\r\n                this.util.preventClick();\r\n                region.fireEvent('update-end', e);\r\n                this.wavesurfer.fireEvent('region-update-end', region, e);\r\n            }\r\n\r\n            region = null;\r\n        };\r\n        this.wrapper.addEventListener('mouseleave', eventUp);\r\n        this.wrapper.addEventListener('mouseup', eventUp);\r\n        this.wrapper.addEventListener('touchend', eventUp);\r\n\r\n        document.body.addEventListener('mouseup', eventUp);\r\n        document.body.addEventListener('touchend', eventUp);\r\n        this.on('disable-drag-selection', () => {\r\n            document.body.removeEventListener('mouseup', eventUp);\r\n            document.body.removeEventListener('touchend', eventUp);\r\n            this.wrapper.removeEventListener('touchend', eventUp);\r\n            this.wrapper.removeEventListener('mouseup', eventUp);\r\n            this.wrapper.removeEventListener('mouseleave', eventUp);\r\n        });\r\n\r\n        const eventMove = event => {\r\n            if (!drag) {\r\n                return;\r\n            }\r\n            if (++pxMove <= slop) {\r\n                return;\r\n            }\r\n\r\n            if (event.touches && event.touches.length > 1) {\r\n                return;\r\n            }\r\n            if (event.targetTouches && event.targetTouches[0].identifier != touchId) {\r\n                return;\r\n            }\r\n\r\n            // auto-create a region during mouse drag, unless region-count would exceed \"maxRegions\"\r\n            if (!region) {\r\n                region = this.add(params || {});\r\n                if (!region) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            const end = this.wavesurfer.drawer.handleEvent(event);\r\n            const startUpdate = this.wavesurfer.regions.util.getRegionSnapToGridValue(\r\n                start * duration\r\n            );\r\n            const endUpdate = this.wavesurfer.regions.util.getRegionSnapToGridValue(\r\n                end * duration\r\n            );\r\n            region.update({\r\n                start: Math.min(endUpdate, startUpdate),\r\n                end: Math.max(endUpdate, startUpdate)\r\n            });\r\n\r\n            let orientedEvent = this.util.withOrientation(event, this.vertical);\r\n\r\n            // If scrolling is enabled\r\n            if (scroll && container.clientWidth < this.wrapper.scrollWidth) {\r\n                // Check threshold based on mouse\r\n                const x = orientedEvent.clientX - wrapperRect.left;\r\n                if (x <= scrollThreshold) {\r\n                    scrollDirection = -1;\r\n                } else if (x >= wrapperRect.right - scrollThreshold) {\r\n                    scrollDirection = 1;\r\n                } else {\r\n                    scrollDirection = null;\r\n                }\r\n                scrollDirection && edgeScroll(event);\r\n            }\r\n        };\r\n        this.wrapper.addEventListener('mousemove', eventMove);\r\n        this.wrapper.addEventListener('touchmove', eventMove);\r\n        this.on('disable-drag-selection', () => {\r\n            this.wrapper.removeEventListener('touchmove', eventMove);\r\n            this.wrapper.removeEventListener('mousemove', eventMove);\r\n        });\r\n\r\n        this.wavesurfer.on('region-created', region => {\r\n            if (this.regionsMinLength) {\r\n                region.minLength = this.regionsMinLength;\r\n            }\r\n        });\r\n    }\r\n\r\n    disableDragSelection() {\r\n        this.fireEvent('disable-drag-selection');\r\n    }\r\n\r\n    /**\r\n     * Get current region\r\n     *\r\n     * The smallest region that contains the current time. If several such\r\n     * regions exist, take the first. Return `null` if none exist.\r\n     *\r\n     * @returns {Region} The current region\r\n     */\r\n    getCurrentRegion() {\r\n        const time = this.wavesurfer.getCurrentTime();\r\n        let min = null;\r\n        Object.keys(this.list).forEach(id => {\r\n            const cur = this.list[id];\r\n            if (cur.start <= time && cur.end >= time) {\r\n                if (!min || cur.end - cur.start < min.end - min.start) {\r\n                    min = cur;\r\n                }\r\n            }\r\n        });\r\n\r\n        return min;\r\n    }\r\n\r\n    /**\r\n     * Match the value to the grid, if required\r\n     *\r\n     * If the regions plugin params have a snapToGridInterval set, return the\r\n     * value matching the nearest grid interval. If no snapToGridInterval is set,\r\n     * the passed value will be returned without modification.\r\n     *\r\n     * @param {number} value the value to snap to the grid, if needed\r\n     * @param {Object} params the regions plugin params\r\n     * @returns {number} value\r\n     */\r\n    getRegionSnapToGridValue(value, params) {\r\n        if (params.snapToGridInterval) {\r\n            // the regions should snap to a grid\r\n            const offset = params.snapToGridOffset || 0;\r\n            return (\r\n                Math.round((value - offset) / params.snapToGridInterval) *\r\n                    params.snapToGridInterval +\r\n                offset\r\n            );\r\n        }\r\n\r\n        // no snap-to-grid\r\n        return value;\r\n    }\r\n}\r\n"
  ],
  "names": [
    "root",
    "factory",
    "exports",
    "module",
    "define",
    "amd",
    "self",
    "__webpack_require__",
    "definition",
    "key",
    "o",
    "Object",
    "defineProperty",
    "enumerable",
    "get",
    "obj",
    "prop",
    "prototype",
    "hasOwnProperty",
    "call",
    "Symbol",
    "toStringTag",
    "value",
    "Region",
    "constructor",
    "params",
    "regionsUtils",
    "ws",
    "this",
    "wavesurfer",
    "wrapper",
    "drawer",
    "util",
    "style",
    "regionsUtil",
    "vertical",
    "id",
    "getId",
    "start",
    "Number",
    "end",
    "scrollWidth",
    "getDuration",
    "resize",
    "undefined",
    "Boolean",
    "drag",
    "isResizing",
    "isDragging",
    "loop",
    "color",
    "handleStyle",
    "left",
    "right",
    "handleLeftEl",
    "handleRightEl",
    "data",
    "attributes",
    "showTooltip",
    "maxLength",
    "minLength",
    "_onRedraw",
    "updateRender",
    "scroll",
    "scrollParent",
    "scrollSpeed",
    "scrollThreshold",
    "preventContextMenu",
    "channelIdx",
    "parseInt",
    "channelCount",
    "regions",
    "splitChannels",
    "regionHeight",
    "marginTop",
    "Math",
    "floor",
    "getHeight",
    "formatTimeCallback",
    "edgeScrollWidth",
    "bindInOut",
    "render",
    "on",
    "fireEvent",
    "update",
    "eventParams",
    "updateHandlesResize",
    "remove",
    "element",
    "removeChild",
    "domElement",
    "un",
    "play",
    "s",
    "playLoop",
    "setLoop",
    "withOrientation",
    "appendChild",
    "document",
    "createElement",
    "className",
    "title",
    "formatTime",
    "setAttribute",
    "attrname",
    "position",
    "height",
    "top",
    "css",
    "cursor",
    "width",
    "backgroundColor",
    "handleLeftCss",
    "assign",
    "handleRightCss",
    "bindEvents",
    "map",
    "time",
    "slice",
    "join",
    "getWidth",
    "pixelRatio",
    "dur",
    "startLimited",
    "endLimited",
    "max",
    "min",
    "round",
    "regionWidth",
    "firedIn",
    "firedOut",
    "onProcess",
    "backend",
    "realTime",
    "getCurrentTime",
    "addEventListener",
    "e",
    "preventDefault",
    "stopPropagation",
    "bindDragEvents",
    "container",
    "startTime",
    "touchId",
    "maxScroll",
    "scrollDirection",
    "wrapperRect",
    "regionLeftHalfTime",
    "regionRightHalfTime",
    "updated",
    "edgeScroll",
    "event",
    "orientedEvent",
    "duration",
    "x",
    "clientX",
    "distanceBetweenCursorAndWrapperEdge",
    "regionHalfTimeWidth",
    "adjustment",
    "getRegionSnapToGridValue",
    "handleEvent",
    "minPxPerSec",
    "wrapperScrollLeft",
    "scrollLeft",
    "calculatedLeft",
    "calculatedRight",
    "delta",
    "onDrag",
    "onResize",
    "window",
    "requestAnimationFrame",
    "onDown",
    "touches",
    "length",
    "targetTouches",
    "identifier",
    "clientWidth",
    "getBoundingClientRect",
    "target",
    "tagName",
    "toLowerCase",
    "classList",
    "contains",
    "onUp",
    "preventClick",
    "onMove",
    "maxEnd",
    "body",
    "passive",
    "removeEventListener",
    "direction",
    "_getDragDirection",
    "action",
    "cursorStyle",
    "RegionsPlugin",
    "name",
    "deferInit",
    "staticProps",
    "addRegion",
    "options",
    "initialisedPluginList",
    "initPlugin",
    "add",
    "clearRegions",
    "clear",
    "enableDragSelection",
    "disableDragSelection",
    "instance",
    "maxRegions",
    "regionsMinLength",
    "getOwnPropertyNames",
    "Observer",
    "forEach",
    "_onBackendCreated",
    "orientation",
    "defaultEdgeScrollWidth",
    "region",
    "list",
    "_onReady",
    "dragSelection",
    "keys",
    "init",
    "isReady",
    "once",
    "destroy",
    "setDisabledEventEmissions",
    "wouldExceedMaxRegions",
    "slop",
    "pxMove",
    "eventDown",
    "y",
    "clientY",
    "buffer",
    "numberOfChannels",
    "channelHeight",
    "clientHeight",
    "channelColors",
    "splitChannelsOptions",
    "dragColor",
    "eventUp",
    "eventMove",
    "startUpdate",
    "endUpdate",
    "getCurrentRegion",
    "cur",
    "snapToGridInterval",
    "offset",
    "snapToGridOffset"
  ],
  "sourceRoot": ""
}
